import { createFragment, createText } from "../dom/helpers";
import { nixixStore } from "../dom/index";
import { LiveFragment } from "../live-fragment/types";

export function comment(str: string) {
  return document.createComment(str);
}

export function indexes(arr: Array<any>) {
  return [arr[0], arr[arr.length - 1]];
}

type CommentName = "suspense" | "for" | "show" | "index";

export function boundary(commentName?: CommentName) {
  const { commentForLF } = nixixStore;
  return commentForLF ? comment(`nixix-${commentName}`) : createText("");
}

export function compFallback() {
  const { commentForLF } = nixixStore;
  return commentForLF ? comment("nixix-fallback") : createText("");
}

export function createBoundary(
  values: any,
  commentName: CommentName
): DocumentFragment {
  return createFragment([boundary(commentName), values, boundary(commentName)]);
}

export function numArray(start: number, end: number) {
  const arr = [];
  for (let index = start; index < end; index++) {
    arr.push(index);
  }
  return arr;
}

export function arrayOfJSX(each: any[], callback: any): any[] {
  const array = each as [];
  const returnedValue = array.map((e, i) => {
    return callback(e, i);
  });
  return returnedValue;
}

export function checkLength(array: any[]) {
  return array.length === 0 ? false : array;
}

export function isArray(el: any) {
  return Array.isArray(el);
}

export function flatten(arr: Array<any>) {
  if (Array.isArray(arr)) return arr.flat(Infinity);
  else return [arr];
}

export function getShow(bool: boolean, children: any, fallback: any) {
  return bool ? children : fallback;
}

/**
 * Removes nodes from a LiveFragment and optionally stores them in a removedNodes array
 * 
 * @param eachLen - The number of nodes to keep in the LiveFragment
 * @param liveFragment - The LiveFragment containing child nodes to process
 * @param removedNodes - Optional array to store removed nodes
 * 
 * Example:
 * Initial state:
 * - LiveFragment has 7 child nodes
 * - eachLen = 4
 * - Nodes to remove = LiveFragment.childNodes.slice(4) = [node5, node6, node7]
 * 
 * After removeNodes(4, liveFragment):
 * - LiveFragment now has 4 child nodes
 * - Removed nodes are either:
 *   a) Stored in removedNodes array if provided
 *   b) Removed from DOM if removedNodes not provided
 * 
 * Multiple calls accumulate removed nodes:
 * removeNodes(2, liveFragment, removedNodes)
 * - Removes nodes 3,4 and adds to start of removedNodes
 * - Final removedNodes = [node3, node4, node5, node6, node7]
 */
export function removeNodes(
  eachLen: number,
  liveFragment: LiveFragment,
  removedNodes?: any[]
) {
  const cachedNodes = liveFragment?.childNodes?.slice(eachLen) as any[];
  removedNodes?.unshift?.(...cachedNodes);
  cachedNodes.forEach((node) => {
    liveFragment.removeChild(node);
    if (!removedNodes) (node as Element).remove()
  });
}

/**
 * Generates an array of nodes by applying a callback function to each element in an array of indices.
 *
 * @param indexArray - An array of indices to use for generating the nodes.
 * @param each - An array of elements to pass to the callback function.
 * @param callback - A function that takes an element from the `each` array and its index, and returns a node.
 * @returns An array of nodes generated by the callback function.
 */
export function getIncrementalNodes(
  indexArray: number[],
  each: any[],
  callback: Required<ForProps>["children"]
) {
  let returnedValue = indexArray.map((index) => {
    return callback(each[index], index) as any;
  });
  return returnedValue;
}
